proc connectAndSet(string $original,string $target){
  $conn=`connectionInfo -sfd $original`;
  if ($conn!=""){
    connectAttr -force $conn $target;
  } else {
    connectAttr -force $original $target;
    disconnectAttr $original $target;
  }
}

/**
 * @param opacity : new shader's opacity attribute
 * @param transparency : old shader's transparency attribute
 * @param color : old shader's color attribute
 * @param isSingleAttr :
 *
**/
proc connectAlpha(string $each, string $replaceWith, string $opacity, string $transparency, string $color, int $isSingleAttr){
	//returns the transparency plug
	string $fileTransparencyAttr = `connectionInfo -sfd ($each + $transparency)`;
	print($fileTransparencyAttr + " ");
	if ($fileTransparencyAttr != ""){
            string $fileAlphaAttr = `substitute .outTransparency $fileTransparencyAttr .outAlpha`;
            print($fileAlphaAttr + "\n");
            //Case of Renderman (and possibly other renderers added in the future)
            if($isSingleAttr == 1) {
            	connectAttr -f $fileAlphaAttr ($replaceWith + $opacity);
            } else {
	           	connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "R");
	            connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "G");
	            connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "B");
            }
        }else {
            string $fileColorAttr = `connectionInfo -sfd ($each + $color)`;
            if ($fileColorAttr != ""){
                string $fileHasAlphaAttr = `substitute .outColor $fileColorAttr .fileHasAlpha`;
                int $hasAlpha = `getAttr $fileHasAlphaAttr`;
                if ($hasAlpha == 1){
                    string $fileAlphaAttr = `substitute .outColor $fileColorAttr .outAlpha`;
                    if($isSingleAttr == 1) {
		            	connectAttr -f $fileAlphaAttr ($replaceWith + $opacity);
		            } else {
			           	connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "R");
			            connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "G");
			            connectAttr -f $fileAlphaAttr ($replaceWith + $opacity + "B");
            		}
                }
            }
        }

}

proc fixFiltering(string $each, string $filter, string $color){
	string $fileColorAttr = `connectionInfo -sfd ($each + $color)`;
	if ($fileColorAttr != ""){
            string $fileFilterAttr = `substitute .outColor $fileColorAttr $filter`;
            catchQuiet (`setAttr $fileFilterAttr 0`);
            $fileFilterAttr = `substitute .outColor $fileColorAttr .filterType`;
            catchQuiet (`setAttr $fileFilterAttr 0`);
    }
}

proc launchConversion(){
	int $input = `radioButtonGrp -q -sl sourceBtnGrp`;
	int $output = `radioButtonGrp -q -sl outputBtnGrp`;

	string $inputStr = btnConverter($input);

    switch($output){
        case 1:
        	runRedshiftConverter($inputStr);
        	break;
        case 2:
      		runArnoldConverter($inputStr);
        	break;
        case 3:
      		runRendermanConverter($inputStr);
        	break;
    }
}

proc string btnConverter(int $input){
	switch($input){
		case 1:
			return "Phong";
        case 2:
        	return "Redshift";
        case 3:
      		return "Arnold";
        case 4:
      		return "Renderman";
    }
}

proc runArnoldConverter(string $source){
	string $sourceColorAttr;
	string $sourceOpacityAttr;
	string $sourceNodeType;
		switch($source){
			case "Phong":
				$sourceColorAttr = ".color";
				$sourceOpacityAttr = ".transparency";
				$sourceNodeType = "phong";
				break;
			case "Redshift":
				$sourceColorAttr = ".diffuse_color";
				$sourceOpacityAttr = ".opacity_color";
				$sourceNodeType = "RedshiftMaterial";
				break;
			case "Renderman":
				$sourceColorAttr = ".diffuseColor";
				$sourceOpacityAttr = ".presence";
				$sourceNodeType = "PxrSurface";
				break;
			case "Arnold":
				return;
		}
	arnoldConverter($sourceColorAttr, $sourceOpacityAttr, $sourceNodeType);
}

proc runRedshiftConverter(string $source){
	string $sourceColorAttr; 
	string $sourceOpacityAttr;
	string $sourceNodeType;
		switch($source){
			case "Phong":
				$sourceColorAttr = ".color";
				$sourceOpacityAttr = ".transparency";
				$sourceNodeType = "phong";
				break;
			case "Arnold":
				$sourceColorAttr = ".baseColor";
				$sourceOpacityAttr = ".opacity";
				$sourceNodeType = "aiStandardSurface";
				break;
			case "Renderman":
				$sourceColorAttr = ".diffuseColor";
				$sourceOpacityAttr = ".presence";
				$sourceNodeType = "PxrSurface";
				break;
			case "Redshift":
				return;
		}
	redshiftConverter($sourceColorAttr, $sourceOpacityAttr, $sourceNodeType);
}

proc runRendermanConverter(string $source){
	string $sourceColorAttr;
	string $sourceOpacityAttr;
	string $sourceNodeType;
		switch($source){
			case "Phong":
				$sourceColorAttr = ".color";
				$sourceOpacityAttr = ".transparency";
				$sourceNodeType = "phong";
				break;
			case "Redshift":
				$sourceColorAttr = ".diffuse_color";
				$sourceOpacityAttr = ".opacity_color";
				$sourceNodeType = "RedshiftMaterial";
				break;
			case "Arnold":
				$sourceColorAttr = ".baseColor";
				$sourceOpacityAttr = ".opacity";
				$sourceNodeType = "aiStandardSurface";
				break;
			case "Renderman":
				return;
		}
	rendermanConverter($sourceColorAttr, $sourceOpacityAttr, $sourceNodeType);
}

// ~~~~~~~~~~ Conversion functions ~~~~~~~~~~

proc arnoldConverter (string $sourceColorAttr, string $sourceOpacityAttr, string $sourceNodeType) {
	string $replaceType = "aiStandardSurface";
	string $sNode[] = `ls -sl`;

	float $i = 0;
	float $total = size($sNode);
	progressWindow
         -title "Converting"
		 sfhfahjs 
		 sfjhsfjsfhjs
		 fhkasfhsjh
		 
         -progress 0
         -status "Converting: Nothing"
         -isInterruptable false;
	
	for($each in $sNode){
		if(`nodeType $each` == $sourceNodeType){
			$i += 1;
	        catchQuiet (`progressWindow -edit
	             -progress ($i / $total * 100)
	             -status ("Converting: "+$each)`);
			
			string $replaceWith = `createNode $replaceType`;
			catchQuiet (`replaceNode $each $replaceWith`);
			//Plugs in the color
			connectAndSet($each + $sourceColorAttr, $replaceWith + ".baseColor");
			//Removes default arnold material specularity
			setAttr ($replaceWith + ".specular") 0;
			setAttr ($replaceWith + ".specularIOR") 1.5;

			connectAlpha($each, $replaceWith, ".opacity", $sourceOpacityAttr, $sourceColorAttr, 0);
	        fixFiltering($each, ".aiFilter", $sourceColorAttr);
			//delete old shader
			delete $each;
			rename $replaceWith $each;
		}
	}
	progressWindow -endProgress;
}


proc redshiftConverter(string $sourceColorAttr, string $sourceOpacityAttr, string $sourceNodeType) {
	string $replaceType = "RedshiftMaterial";
    string $sNode[] = `ls -sl`;  

    float $i = 0;
    float $total = size($sNode);
    progressWindow
	    -title "Converting"
	    -progress 0
	    -status "Converting: Nothing"
	    -isInterruptable false;  
    
    for ($each in $sNode){
    	if(`nodeType $each` == $sourceNodeType){
	    	$i += 1;
	        catchQuiet (`progressWindow -edit
	             -progress ($i / $total * 100)
	             -status ("Converting: "+$each)`);

	        string $replaceWith = `createNode $replaceType`;
	        catchQuiet (`replaceNode $each $replaceWith`);
	        connectAndSet($each + $sourceColorAttr, $replaceWith + ".diffuse_color");
	        // Plugging in the Color
	        setAttr ($replaceWith + ".refl_weight") 0.1;
	        setAttr ($replaceWith + ".refl_ior") 1;

	        // Gets shader and looks at transparency input
	        connectAlpha($each, $replaceWith,".opacity_color", $sourceOpacityAttr, $sourceColorAttr, 0);
	        fixFiltering($each, ".rsFilterEnable", $sourceColorAttr);
	        //delete old shader
		    delete $each;
		    rename $replaceWith $each;
    	}
    }
    progressWindow -endProgress;
}


proc rendermanConverter (string $sourceColorAttr, string $sourceOpacityAttr, string $sourceNodeType) {
	string $replaceType = "PxrSurface";
	string $sNode[] = `ls -sl`;

	float $i = 0;
	float $total = size($sNode);
	progressWindow
         -title "Converting"
         -progress 0
         -status "Converting: Nothing"
         -isInterruptable false;
	
	for($each in $sNode){
		if(`nodeType $each` == $sourceNodeType){
			$i += 1;
	        catchQuiet (`progressWindow -edit
	             -progress ($i / $total * 100)
	             -status ("Converting: "+$each)`);
			
			string $replaceWith = `createNode $replaceType`;
			catchQuiet (`replaceNode $each $replaceWith`);
			//Plugs in the color
			connectAndSet($each + $sourceColorAttr, $replaceWith + ".diffuseColor");
	    	setAttr ($replaceWith + ".diffuseDoubleSided") 1;

			connectAlpha($each, $replaceWith, ".presence", $sourceOpacityAttr, $sourceColorAttr, 1);
			fixFiltering($each, ".rman__filter", $sourceColorAttr);
			//delete old shader
			delete $each;
			rename $replaceWith $each;
		}
	}
	progressWindow -endProgress;
}
       
// ~~~~~~~~~~ UI ~~~~~~~~~~

proc createUI() {
	if (`window -exists matWindow`) {
    deleteUI matWindow;
}

window -title "Material Converter" matWindow;
    columnLayout -adjustableColumn true;
        text -label "WARNING: Use Phong as source if you just imported the model." -align "center" -height 30 -font "boldLabelFont";
        separator -style "in" -height 5;

    
    formLayout -numberOfDivisions 4 sourceBtn;
    radioButtonGrp
         -numberOfRadioButtons 4
         -label "1. Source shader:          "
         -labelArray4 "Phong (default)" "Redshift" "Arnold" "Renderman"
         -select 1
         sourceBtnGrp;

    formLayout -edit
         -attachForm sourceBtnGrp "top" 4
         -attachForm sourceBtnGrp "left" -20
         sourceBtn;
    setParent..;     
    

    formLayout -numberOfDivisions 3 outputBtn;
    radioButtonGrp
         -numberOfRadioButtons 3
         -label "2. Output shader:          "
         -labelArray3 "Redshift" "Arnold" "Renderman"
         outputBtnGrp;

    formLayout -edit
         -attachForm outputBtnGrp "top" 20
         -attachForm outputBtnGrp "left" -20
         outputBtn;
    setParent..;    
    
    columnLayout -adjustableColumn true -co "both" 25;
        separator -style "in" -height 20;
        //button -h 25 -w 80 -label "3. Convert!" -command "launchConversion(`radioButtonGrp -q -sl sourceBtnGrp`, `radioButtonGrp -q -sl outputBtnGrp`)" ;
        button -h 25 -w 80 -label "3. Convert!" -command "launchConversion" ;
        text -label "by   <a href=\"https://twitter.com/Antrelial\" style=\"color:grey\"> Antoine B. </a>" 
                                                -align "center" -font "smallBoldLabelFont" -hyperlink true -h 50;
    setParent..;
	    
	showWindow matWindow;
	window -e -wh 570 190 matWindow;

}

createUI();